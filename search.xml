<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git 删除误加工作区的文件</title>
      <link href="/git/56905.html"/>
      <url>/git/56905.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平时工作中，我经常会遇到这样的一个问题：一不小心把编译好的二进制文件上传了，或者把本地的配置文件上传到了git服务器。这种时候设置<code>.gitignore</code> 已经无法撤销了，这时候就需要进行删除操作。<br>删除有分两种情况：1. 删除本地和远程；2. 仅删除远程</p><h1 id="删除本地和远程"><a href="#删除本地和远程" class="headerlink" title="删除本地和远程"></a>删除本地和远程</h1><h2 id="删除并提交修改"><a href="#删除并提交修改" class="headerlink" title="删除并提交修改"></a>删除并提交修改</h2><p>这种就是利用git的工作原理，在本地删除文件后，让git生成一个删除文件的更改记录，然后将这个更改记录提交给服务器。<br>操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm [filename] <span class="comment"># 或 git rm [filename]</span></span><br><span class="line">$ git add . <span class="comment"># 缓存此次修改</span></span><br><span class="line">$ git commit -m <span class="string">'删除文件[filename]'</span> <span class="comment"># 提交</span></span><br></pre></td></tr></table></figure><blockquote><p>这个方法有个问题，就是如果跟你协作的人也有这个文件，很容易把别人的一起删除了。这个时候更适合删除缓存了。</p></blockquote><h1 id="删除远程并本地保留"><a href="#删除远程并本地保留" class="headerlink" title="删除远程并本地保留"></a>删除远程并本地保留</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached [filename] <span class="comment"># 删除远程缓存</span></span><br></pre></td></tr></table></figure><p>这时候如果文件已提交，会生成两条记录，一条是【暂存的更改】，一条是【更改】。只需要<code>$ git add .</code>然后就会合并，该文件就会取消跟踪。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 日常工作系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题系列-03 无重复字符的最长子串</title>
      <link href="/leetcode/14339.html"/>
      <url>/leetcode/14339.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><blockquote><p><strong>输入</strong>: “abcabcbb”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p>示例 2:</p><blockquote><p><strong>输入</strong>: “bbbbb”<br><strong>输出</strong>: 1<br><strong>解释</strong>: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p>示例 3:</p><blockquote><p><strong>输入</strong>: “pwwkew”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>来源：力扣（LeetCode）</p><footer><strong>力扣</strong><cite><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">无重复字符的最长子串</a></cite></footer></blockquote><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        s_len = len(s)</span><br><span class="line">        <span class="keyword">if</span> s_len &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s_len</span><br><span class="line"></span><br><span class="line">        sub_len = <span class="number">1</span></span><br><span class="line">        sub_start = <span class="number">0</span></span><br><span class="line">        sub_end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> sub_end &lt; s_len:</span><br><span class="line">            sub_end = sub_end + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sub_end == s_len:</span><br><span class="line">                sub_len = max(sub_len, sub_end - sub_start)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            f_index = s.find(s[sub_end], sub_start, sub_end)</span><br><span class="line">            <span class="keyword">if</span> f_index == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sub_len = max(sub_len, sub_end - sub_start)</span><br><span class="line">            sub_start = f_index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sub_len</span><br></pre></td></tr></table></figure><blockquote><p>下一篇打算试试 《04 寻找两个有序数组的中位数》 <a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">预习题目</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题系列-02 两数相加</title>
      <link href="/leetcode/26858.html"/>
      <url>/leetcode/26858.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><footer><strong>力扣</strong><cite><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加</a></cite></footer></blockquote><h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">createNone</span><span class="params">(ll, lr, di)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> ll <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> lr <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> di == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = ListNode(di)</span><br><span class="line">            <span class="keyword">if</span> ll <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                node.val = node.val + ll.val</span><br><span class="line">                ll = ll.next</span><br><span class="line">            <span class="keyword">if</span> lr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                node.val = node.val + lr.val</span><br><span class="line">                lr = lr.next</span><br><span class="line">            node.next = createNone(ll, lr, int(node.val / <span class="number">10</span>))</span><br><span class="line">            node.val = node.val % <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> createNone(l1, l2, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题系列-01 两数之和</title>
      <link href="/leetcode/31441.html"/>
      <url>/leetcode/31441.html</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>示例：</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><footer><strong>力扣</strong><cite><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></cite></footer></blockquote><h1 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        results = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                t = nums[i + <span class="number">1</span>:].index(target - v)</span><br><span class="line">                <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                results = [i, t + x + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    print(sol.twoSum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">9</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode 刷题记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 基础知识系列- 2 字符串</title>
      <link href="/basecharp/%E5%AD%97%E7%AC%A6%E4%B8%B2/e6999e60.html"/>
      <url>/basecharp/%E5%AD%97%E7%AC%A6%E4%B8%B2/e6999e60.html</url>
      
        <content type="html"><![CDATA[<h1 id="String的常见方法"><a href="#String的常见方法" class="headerlink" title="String的常见方法"></a>String的常见方法</h1><h2 id="String-变量的声明方式"><a href="#String-变量的声明方式" class="headerlink" title="String 变量的声明方式"></a>String 变量的声明方式</h2><p>C#中字符串常见的声明有两种：</p><ol><li>直接使用字面值 即<code>String s = &quot;12321&quot;;</code></li><li>使用构造器，即<code>String s = new String(&quot;12321&quot;);</code></li></ol><h2 id="string-的特点"><a href="#string-的特点" class="headerlink" title="string 的特点"></a>string 的特点</h2><p><code>String</code>（字符串）在大多数开发语言中属于不可变量，任何针对String的修改都会生成一个新的字符串。为什么会如此呢，究其原因是String在内存中以类似数组的形式存储字符数据。同时，<code>String</code> 还有一个非常有意思的特点： 字符串在一次声明后，程序会记忆当前已声明的字符串，以备下次使用时不用重新划分内存。<br>关于这一点有个很有意思（智障）的面试题：</p><blockquote><p>以下三种方式一共生成了几个内存空间：</p></blockquote><ol><li>string s1 = “sa1234”;</li><li>string s2 = “sa”+”1234”;</li><li>string s3 = new string(s1);</li></ol><p>很多人包括一些老开发都会认为是4个，那么实际上呢，s2和s1同时指向了一个地址也就是两个。<br>嗯？是不是有点不可思议？</p><p>这个是因为在C#中，字面值有一个特点，如果声明过程中一个变量的声明使用的都是字面值（即非变量）或者是常量，那么该变量的声明过程会优先计算值，然后将该变量指向一个常量。<br>也就是说 在<code>string s2 = &quot;sa&quot;+&quot;1234&quot;;</code>这个表达式中，会先将”sa”和”1234”合并成一个字符串，再赋值给s2。并不会先划分一个”sa”的内存区域，再划分一个”1234”的内存区域，最后再合并成”sa1234“。所以1和2都是直接指向”sa1234”。</p><h2 id="string的构造函数"><a href="#string的构造函数" class="headerlink" title="string的构造函数"></a>string的构造函数</h2><p><code>string</code>的构造函数一共有以下几种：</p><ol><li><code>public String(char c, int count);</code></li><li><code>public String(char[] value)；</code></li><li><code>public String(char[] value, int startIndex, int length)；</code></li><li>其他</li></ol><p>第一个： 生成数量为count的由c组成的字符串，不包括其他字符。<br>例：<code>string  s = new String(&#39;a&#39;,10);//s=&quot;aaaaaaaaaa&quot;</code><br>第二个： 将字符数组value转换为字符串，字符串等于字符数组依次连接生成的字符串<br>例：<code>string s = new String(new char[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;});//s = &quot;abcde&quot;</code><br>第三个： 将字符数组value中部分元素拼接为字符串<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var chars &#x3D; new char[] &#123;&#39;A&#39;, &#39;V&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;;</span><br><span class="line">var sr &#x3D; new string(chars, 0, 5);&#x2F;&#x2F;sr &#x3D; &quot;AVabc&quot;</span><br></pre></td></tr></table></figure><p>第四个：这里面包括了一些不安全代码，即用到了指针。有机会会对这部分进行介绍。</p><p>但是，到这里我们发现一个问题，<code>new string(string str)</code>在哪，前面不是使用了一个 <code>new string(&quot;12321&quot;)</code>吗？<br>事实是，并没有这个构造函数。那么，当我们使用<code>new string(&quot;12321&quot;)</code>时，实际上是哪个呢？显然可以看到它走的是 <strong>第二种</strong> ，系统将字符串当做字符数组传递给了<code>string</code>的构造函数。这也为我们揭露了string在内存中的存储方式-字符数组。由此可见字符串的不可变性其实跟数组类似。</p><h2 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h2><p>在string类里有一个很有意思的静态属性：<code>string.Empty</code> 。它是一个常量，表示空字符串。空字符串，顾名思义：一个空的字符串，不含任何字符，但是不是NULL。</p><h3 id="空字符串与NULL的区别"><a href="#空字符串与NULL的区别" class="headerlink" title="空字符串与NULL的区别"></a>空字符串与NULL的区别</h3><ul><li>空字符串是一个长度为0的字符串；NULL没有长度，如果强行获取.Length将抛出异常</li><li>空字符串可以调用字符串所有的方法；NULL无法调用字符串对象的任何方法</li><li>空字符串指向的是内存中的某一个地址，NULL则没有任何指向</li></ul><h3 id="判断字符串是否为空："><a href="#判断字符串是否为空：" class="headerlink" title="判断字符串是否为空："></a>判断字符串是否为空：</h3><ol><li>字符串是否是空字符串：</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str = <span class="keyword">string</span>.Empty;</span><br><span class="line"><span class="keyword">bool</span> result = str == <span class="string">""</span> || str == <span class="keyword">string</span>.Empty || str.Length == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串是否是空引用：</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> str = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">bool</span> result = str == <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>除了这些繁琐的方法，c# 内部为我们增加了一个默认支持方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.IsNullOrEmpty(value)</span><br></pre></td></tr></table></figure><p>该方法验证字符串是否是NULL或者一个空串并返回验证结果<br>当然，在我们平时开发过程中不只是需要不是一个空串或NULL，还得是一个非空白字符的串。这时候就需要用到这个方法了:<code>string.IsNullOrWhiteSpace(value)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C#基础知识 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础知识 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 基础知识系列- 1 数据类型</title>
      <link href="/basecharp/381553b5.html"/>
      <url>/basecharp/381553b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h1><p>C#的类型一般分为<strong>值类型</strong>、<strong>引用类型</strong>两大类型。<br>值类型的实例存放在栈中，引用类型会在栈中放置一个指针指向堆中的某一块内容。<br>C#为我们内置了几个数据类型供我们使用：</p><table><thead><tr><th align="center">关键词简写</th><th align="left">对应的类全称(点击可以查看对应的API)</th><th align="left">值范围</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">bool</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.Boolean" target="_blank" rel="noopener"><code>System.Boolean</code></a></td><td align="left">true、false</td><td align="left"><code>该类型只有两个值，用作判断，表示“是”、“否”</code></td></tr><tr><td align="center">sbyte</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.SByte" target="_blank" rel="noopener"><code>System.SByte</code></a></td><td align="left">-128 ~ 127 (-2<sup>7</sup>~2<sup>7</sup>-1)</td><td align="left"><code>该类型在内存中使用8个bit进行存储，而且带有符号。</code><br/><code>根据最高位作符号位，所以sbyte实际表示范围为 -128~127</code></td></tr><tr><td align="center">byte</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.byte" target="_blank" rel="noopener"><code>System.Byte</code></a></td><td align="left">0~2<sup>8</sup>-1</td><td align="left"><code>8位的无符号bit</code></td></tr><tr><td align="center">short</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.Int16" target="_blank" rel="noopener"><code>System.Int16</code></a></td><td align="left">-2<sup>15</sup>~2<sup>15</sup>-1</td><td align="left"><code>short表示一个16位的短整形，其具体的值为-32768～32767</code></td></tr><tr><td align="center">ushort</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.UInt16" target="_blank" rel="noopener"><code>System.UInt16</code></a></td><td align="left">0～2<sup>16</sup>-1</td><td align="left"><code>ushort表示无符号16位的短整型，具体的范围为0～65535</code></td></tr><tr><td align="center">int</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.Int32" target="_blank" rel="noopener"><code>System.Int32</code></a></td><td align="left">-2<sup>15</sup>~2<sup>15</sup>-1</td><td align="left"><code>int是我们常用的一个数据类型，它的数据范围为： -2,147,483,648～ 2,147,483,647 。</code><br/><code>可以看到，是-2亿到2亿，基本满足了数据需要。</code></td></tr><tr><td align="center">uint</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.UInt32" target="_blank" rel="noopener"><code>System.UInt32</code></a></td><td align="left">0~2<sup>32</sup>-1</td><td align="left"><code>uint 无符号整形，最大值比 int大一倍左右，但是没有负数。</code><br/><code>如果在计算中能保证没有负值，可以使用。</code><br/><code>并不推荐，因为在做减法的时候，更、容易溢出</code></td></tr><tr><td align="center">long</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.Int64" target="_blank" rel="noopener"><code>System.Int64</code></a></td><td align="left">-2<sup>16</sup>~2<sup>16</sup>-1</td><td align="left"><code>实际取值为-9,223,372,036,854,775,808~ 9,223,372,036,854,775,807 。</code><br/><code>long在内存中比int占用更多字节，长度为int的两倍。</code><br/><code>所以能表达更多的数剧。在数据库中，经常被用来做大数据表的主键。</code></td></tr><tr><td align="center">ulong</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.UInt64" target="_blank" rel="noopener"><code>System.UInt64</code></a></td><td align="left">0~2<sup>64</sup>-1</td><td align="left"><code>64位无符号长整形，理同其他的无符号整形，在正整数中比long表达更多的数据。</code></td></tr><tr><td align="center">char</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.char" target="_blank" rel="noopener"><code>System.Char</code></a></td><td align="left">utf-16</td><td align="left"><code>在.net 中char 表示 utf-16的编码单位，所以绝大多数的字符都可以用char表示，包括中文汉字。</code></td></tr><tr><td align="center">float</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.single" target="_blank" rel="noopener"><code>System.Single</code></a></td><td align="left">-3.402823e38～3.402823e38</td><td align="left"><code>32位的单精度浮点型，也就是通常说的带小数点的数</code></td></tr><tr><td align="center">double</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.double" target="_blank" rel="noopener"><code>System.Double</code></a></td><td align="left"></td><td align="left"><code>64位双精度浮点型，比float能表示更多的小数位。</code><br/><code>实际取值-1.79769313486232e308～1.79769313486232e308</code></td></tr><tr><td align="center">decimal</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal" target="_blank" rel="noopener"><code>System.Decimal</code></a></td><td align="left"></td><td align="left"><code>128位高精度浮点值。</code><br/><code>常用于不能四舍五入，或者对小数点后数字要求很敏感的地方。</code><br/><code>在128位中，一位是符号位（表示正负），96位是值本身（N）,8位是比例因子（k)。</code><br/><code>所以decimal实际值应该是</code> ±Nx10<sup>k</sup><code>,其中-28≤k≤0.其余位暂时没有使用</code></td></tr><tr><td align="center">string</td><td align="left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.string" target="_blank" rel="noopener"><code>System.String</code></a></td><td align="left">–</td><td align="left"><code>字符串变量，表示一组字符数组。字符串是不可变量。即字符串不能修改，任何针对字符串的修改都会生成一个新的字符串。</code></td></tr></tbody></table><p>另外的两个特殊类型：<code>dynamic</code> <code>object</code>。<br>其中 dynamic 表示动态类型，这是C#在4.0开始支持的，<code>dynamic</code>关键字声明该变量名是个动态变量。具体使用参照 Python,Js 之类的动态语言。但是<code>dynamic</code>声明的变量不支持添加属性，但这并不完全绝对，可以参照后续的动态篇会对这部分内容进行介绍。</p><p><code>object</code> 所有类型的父类，C#所有类都是 object的子类。不过上表中介绍的直接父类是 ValueType（表示值类型），但是ValueType的父类仍然是object。</p><blockquote><p>说明：<br>对于 double 和 float 因为存储数据方式的问题，都存在一个问题：对于 0 或者近0的值不能很好的表达。因为浮点型变量在内存中表示为 1/2<sup>n</sup>，所以都会存在一个+0和-0两个值。当 一个浮点型判断是不是等于0时，可以正常判断。但是一旦涉及到数学运算的结果与0进行比较的话就会出现问题，比如说 <code>0.1+0.2 != 0.3</code> 这个判断式是 <code>true</code>。所以标准的判断方式应该是 <code>Math.Abs(0.1+0.2 - 0.3)&lt; ?</code> 这种方式，其中?表示系统接受的误差范围。<br>而decimal在这方面的准确度就比 double和float高很多。至少不会出现 0.1 + 0.2 != 0.3 这种问题。所以decimal一般用在金额计算这些地方。</p></blockquote><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>类型转换是指一个类型的数值通过某种手段转换成另一种类型。<br>类型转换分为两种方式：<strong>默认类型转换</strong>、<strong>强制类型转换</strong>。</p><h2 id="默认类型转换"><a href="#默认类型转换" class="headerlink" title="默认类型转换"></a>默认类型转换</h2><p>在以下几种情况会触发默认类型转换：</p><ul><li>当一个子类想转换成它的父类时，</li><li>当短精度向高精度转换时。<br>如： byte -&gt; int -&gt; long -&gt; float -&gt; double<br>参照：</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = i;</span><br><span class="line"><span class="keyword">float</span> f = i;</span><br><span class="line">d = f;</span><br><span class="line"><span class="keyword">uint</span> ui = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> l = ui;</span><br><span class="line">d = l;</span><br><span class="line">f = l;</span><br></pre></td></tr></table></figure><p>这里有几个需要特别注意的地方：</p><ul><li>无符号和有符号之间的转换，如果无符号的位数与有符号之间的位数一致的话不能默认转换。</li><li>decimal 所有的整型均可以默认转为 <code>decimal</code>，即 除 <code>double</code>、<code>float</code>以外所有数字类型的均可以。</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="数据类型判断-is-："><a href="#数据类型判断-is-：" class="headerlink" title="数据类型判断 is ："></a>数据类型判断 <code>is</code> ：</h3><p>C# 内置了一个关键字 用来 判断 某个变量是否是某个类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> : <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">        A a = b;</span><br><span class="line">        <span class="comment">// 这时候 a 是一个 假装自己是A的B的引用</span></span><br><span class="line">        Console.WriteLine(<span class="string">"a is B ? &#123;0&#125;"</span>, a <span class="keyword">is</span> B); <span class="comment">// 结果： true</span></span><br><span class="line">        Console.WriteLine(<span class="string">"a is A ? &#123;0&#125;"</span>, a <span class="keyword">is</span> A); <span class="comment">// true</span></span><br><span class="line">        Console.WriteLine(<span class="string">"a is C ? &#123;0&#125;"</span>, a <span class="keyword">is</span> C); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么<code>is</code>有什么用呢？在强制类型转换之前检测一下是否可以转换为目标类型，如果返回值为 false 依旧要转换的话，那么就会报错。</p><h3 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换分为两种：</p><ol><li>在变量前加目标类型强制转换，这个方法与C/C++、Java的方式一致，具体为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 &#x3D; (C)a;&#x2F;&#x2F; 代码接上</span><br></pre></td></tr></table></figure></li><li>使用<code>as</code>关键字，<code>as</code> 表示将变量 x 当做类型Y<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c2 &#x3D; a as C;&#x2F;&#x2F; 代码接上</span><br></pre></td></tr></table></figure></li></ol><p>两种方式的区别：</p><ol><li><p>当转型失败时会抛出错误，直接终止代码</p></li><li><p>当转型失败时将c2置为null。当前步骤不会抛出异常，如果对于空引用没有进行处理，那么会在<strong><em>后续</em></strong>中抛出空引用的异常。</p></li></ol><h3 id="值类型的类型转换"><a href="#值类型的类型转换" class="headerlink" title="值类型的类型转换"></a>值类型的类型转换</h3><p>在之前的内容中我们提到了小精度到大精度可以默认转换。但是我们在平常使用的过程中会遇到各种情况下的转换，那么这个时候我们就要用到强制转换了，这个时候精度丢失对于我们来说就是可以接受的。<br>常见的转换方式有：</p><ol><li>使用类型强制声明转换 例：<code>long lval = 100; int i = (int)lval;</code></li><li>使用 System.Convert类。使用 <code>Convert.ToXXX()</code>，其中<code>XXX</code>表示转型目标对象。</li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Convert 示例代码</span></span><br><span class="line"><span class="keyword">long</span> lval = <span class="number">19293</span>;</span><br><span class="line"><span class="keyword">var</span> i = Convert.ToInt32(lval);</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10.091</span>;</span><br><span class="line"><span class="keyword">var</span> dc = Convert.ToDecimal(d);</span><br><span class="line"><span class="keyword">var</span> dt = Convert.ToDateTime(<span class="string">"2019-03-30"</span>);</span><br></pre></td></tr></table></figure><p>值得注意的是：<code>Convert</code>的ToXXX其中XXX使用的是C#类型名称，而不是关键字。<code>Convert</code>是个很有用的类，在我们开发工作中会大量的使用这个类进行值的类型转换。<br>当然后续我们会对其进行更深入的介绍。</p>]]></content>
      
      
      <categories>
          
          <category> C#基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础知识 </tag>
            
            <tag> C# 基础数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IT  技能图谱</title>
      <link href="/others/45148.html"/>
      <url>/others/45148.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/5a45a0a5ab64411cab00092a.png" alt="2.2 Java并发图谱"></p><h2 id="2-1-3-Java集合图谱"><a href="#2-1-3-Java集合图谱" class="headerlink" title="2.1.3 Java集合图谱"></a>2.1.3 Java集合图谱</h2><p><img src="/images/5a45bf81ab64411e95000eff.png" alt="2.3 Java集合图谱"></p><h2 id="2-1-4-Java集合类图"><a href="#2-1-4-Java集合类图" class="headerlink" title="2.1.4 Java集合类图"></a>2.1.4 Java集合类图</h2><p><img src="/images/5a45bf81ab64411e95000f05.png" alt="2.4 Java集合类图"></p><h2 id="2-1-5-Java-List类图"><a href="#2-1-5-Java-List类图" class="headerlink" title="2.1.5 Java List类图"></a>2.1.5 Java List类图</h2><p><img src="/images/5a45bf81ab64411e95000f01.png" alt="2.5 Java List类图"></p><h2 id="2-1-6-Java-Map类图"><a href="#2-1-6-Java-Map类图" class="headerlink" title="2.1.6 Java Map类图"></a>2.1.6 Java Map类图</h2><p><img src="/images/5a45bf81ab64411e95000ef4.png" alt="2.6 Java Map类图"></p><h2 id="2-1-7-Java-Set类图"><a href="#2-1-7-Java-Set类图" class="headerlink" title="2.1.7 Java Set类图"></a>2.1.7 Java Set类图</h2><p><img src="/images/5a45bf81ab64411e95000f08.png" alt="2.7 Java Set类图"></p><h2 id="2-1-8-Java-TCP-IP"><a href="#2-1-8-Java-TCP-IP" class="headerlink" title="2.1.8 Java TCP/IP"></a>2.1.8 Java TCP/IP</h2><p><img src="/images/5a45bf81ab64411e95000ef7.png" alt="2.8 Java TCP IP"></p><h1 id="3-1-Hadoop技能图谱"><a href="#3-1-Hadoop技能图谱" class="headerlink" title="3.1 Hadoop技能图谱"></a>3.1 Hadoop技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000f06.png" alt="3.1 Hadoop技能图谱"></p><h1 id="3-2-大数据技能图谱"><a href="#3-2-大数据技能图谱" class="headerlink" title="3.2 大数据技能图谱"></a>3.2 大数据技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000ef6.png" alt="3.2 大数据技能图谱"></p><h1 id="4-1-云计算图谱"><a href="#4-1-云计算图谱" class="headerlink" title="4.1 云计算图谱"></a>4.1 云计算图谱</h1><p><img src="/images/5a45bf81ab64411e95000efd.png" alt="4.1 云计算图谱"></p><h1 id="4-2-云计算技能图谱"><a href="#4-2-云计算技能图谱" class="headerlink" title="4.2 云计算技能图谱"></a>4.2 云计算技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000ef8.png" alt="4.2 云计算技能图谱"></p><h1 id="5-1-IOS技能图谱"><a href="#5-1-IOS技能图谱" class="headerlink" title="5.1 IOS技能图谱"></a>5.1 IOS技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000f09.png" alt="5.1 IOS技能图谱"></p><h1 id="5-2-OpenResty技能图谱"><a href="#5-2-OpenResty技能图谱" class="headerlink" title="5.2 OpenResty技能图谱"></a>5.2 OpenResty技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000efa.png" alt="5.2 OpenResty技能图谱"></p><h1 id="5-3-前端技能图谱"><a href="#5-3-前端技能图谱" class="headerlink" title="5.3 前端技能图谱"></a>5.3 前端技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000f0c.png" alt="5.3 前端技能图谱"></p><h1 id="5-4-容器技能图谱"><a href="#5-4-容器技能图谱" class="headerlink" title="5.4 容器技能图谱"></a>5.4 容器技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000ef3.png" alt="5.4 容器技能图谱"></p><h1 id="5-5-嵌入式开发技能图谱"><a href="#5-5-嵌入式开发技能图谱" class="headerlink" title="5.5 嵌入式开发技能图谱"></a>5.5 嵌入式开发技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000ef2.png" alt="5.5 嵌入式开发技能图谱"></p><h1 id="5-6-开发语言宝典"><a href="#5-6-开发语言宝典" class="headerlink" title="5.6 开发语言宝典"></a>5.6 开发语言宝典</h1><p><img src="/images/5a45bf81ab64411e95000efb.png" alt="5.6 开发语言宝典"></p><h1 id="5-7-移动端测试图谱"><a href="#5-7-移动端测试图谱" class="headerlink" title="5.7 移动端测试图谱"></a>5.7 移动端测试图谱</h1><p><img src="/images/5a45bf81ab64411e95000f02.png" alt="5.7 移动端测试图谱"></p><h1 id="5-8-运维技能图谱"><a href="#5-8-运维技能图谱" class="headerlink" title="5.8 运维技能图谱"></a>5.8 运维技能图谱</h1><p><img src="/images/5a45bf81ab64411e95000f03.png" alt="5.8 运维技能图谱"></p><h1 id="5-9-软件工程"><a href="#5-9-软件工程" class="headerlink" title="5.9 软件工程"></a>5.9 软件工程</h1><p><img src="/images/5a45bf81ab64411e95000f00.png" alt="5.9 软件工程"></p><h1 id="5-10-DevOps"><a href="#5-10-DevOps" class="headerlink" title="5.10 DevOps"></a>5.10 DevOps</h1><p><img src="/images/5a45bf81ab64411e95000f04.png" alt="5.10 DevOps"></p><h1 id="5-11-前端开发"><a href="#5-11-前端开发" class="headerlink" title="5.11 前端开发"></a>5.11 前端开发</h1><p><img src="/images/5a45bf81ab64411e95000f07.png" alt="5.11 前端开发"></p><h1 id="5-12-后端开发"><a href="#5-12-后端开发" class="headerlink" title="5.12 后端开发"></a>5.12 后端开发</h1><p><img src="/images/5a45bf81ab64411e95000f0b.png" alt="5.12 后端开发"></p><h1 id="5-13-软件发布流程"><a href="#5-13-软件发布流程" class="headerlink" title="5.13 软件发布流程"></a>5.13 软件发布流程</h1><p><img src="/images/5a45bf81ab64411e95000efc.png" alt="5.13 软件发布流程"></p><h1 id="5-14-DBA-技能图谱1-0"><a href="#5-14-DBA-技能图谱1-0" class="headerlink" title="5.14 DBA 技能图谱1.0"></a>5.14 DBA 技能图谱1.0</h1><p><img src="/images/5a45bf81ab64411e95000f0a.png" alt="5.14 DBA 技能图谱1.0"></p><h1 id="5-15-H5技能图谱1-0"><a href="#5-15-H5技能图谱1-0" class="headerlink" title="5.15 H5技能图谱1.0"></a>5.15 H5技能图谱1.0</h1><p><img src="/images/5a45bf81ab64411e95000ef5.png" alt="5.15 H5技能图谱1.0"></p><h1 id="5-16-移动性能优化1-0"><a href="#5-16-移动性能优化1-0" class="headerlink" title="5.16 移动性能优化1.0"></a>5.16 移动性能优化1.0</h1><p><img src="/images/5a45bf81ab64411e95000ef5.png" alt="5.16 移动性能优化1.0"></p><h1 id="5-17-机器学习技能图谱"><a href="#5-17-机器学习技能图谱" class="headerlink" title="5.17 机器学习技能图谱"></a>5.17 机器学习技能图谱</h1><p><img src="/images/pasted-1.png" alt="机器学习技能图谱"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IT 图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express 基础入门</title>
      <link href="/express/deceab70.html"/>
      <url>/express/deceab70.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>该文档整理自 Express官方文档</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir myapp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myapp</span></span><br></pre></td></tr></table></figure><p>通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">Specifics of npm’s package.json handling</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm init</span></span><br></pre></td></tr></table></figure><p>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry point: (index.js)</span><br></pre></td></tr></table></figure><p>键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。</p><p>接下来安装 Express 并将其保存到依赖列表中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express --save</span></span><br></pre></td></tr></table></figure><p>如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 <code>--save</code>参数即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express</span></span><br></pre></td></tr></table></figure><p>安装 Node 模块时，如果指定了 <code>--save</code>参数，那么此模块将被添加到 <code>package.json</code> 文件中 <code>dependencies</code> 依赖列表中。 然后通过 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块。</p><hr><h1 id="Hello-world-实例"><a href="#Hello-world-实例" class="headerlink" title="Hello world 实例"></a>Hello world 实例</h1><p>继续之前请务必按照 <a href="#安装">安装</a> 章节执行了所有的前期准备工作。</p><p>接下来，我们一起创建一个基本的 Express 应用。</p><p>注意：这里所创建是一个最最简单的 Express 应用，并且仅仅只有一个文件 — 和通过 <a href="#Express应用生成器">Express 应用生成器</a> 所创建的应用<strong>完全不一样</strong>，Express 应用生成器所创建的应用框架包含多个 JavaScript 文件、Jade 模板和针对不同用途的子目录。</p><p>进入 myapp 目录，创建一个名为 app.js 的文件，然后将下列代码复制进去：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening at http://%s:%s'</span>, host, port);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。</p><blockquote><p>req (请求) 和 res (响应) 与 Node 提供的对象完全一致，因此，你可以调用 req.pipe()、req.on(‘data’, callback) 以及任何 Node 提供的方法。</p></blockquote><p>通过如下命令启动此应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node app.js</span></span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 并查看输出结果。</p><h1 id="Express应用生成器"><a href="#Express应用生成器" class="headerlink" title="Express应用生成器"></a>Express应用生成器</h1><p>通过应用生成器工具 express 可以快速创建一个应用的骨架。</p><p>通过如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install express-generator -g</span></span><br></pre></td></tr></table></figure><p>-h 选项可以列出所有可用的命令行选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> express -h</span></span><br><span class="line"></span><br><span class="line">  Usage: express [options] [dir]</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line"></span><br><span class="line">    -h, --help          output usage information</span><br><span class="line">    -V, --version       output the version number</span><br><span class="line">    -e, --ejs           add ejs engine support (defaults to jade)</span><br><span class="line">        --hbs           add handlebars engine support</span><br><span class="line">    -H, --hogan         add hogan.js engine support</span><br><span class="line">    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support (less|stylus|compass|sass) (defaults to plain css)</span><br><span class="line">        --git           add .gitignore</span><br><span class="line">    -f, --force         force on non-empty directory</span><br></pre></td></tr></table></figure><p>例如，下面的示例就是在当前工作目录下创建一个命名为 myapp 的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> express myapp</span></span><br><span class="line"></span><br><span class="line">   create : myapp</span><br><span class="line">   create : myapp/package.json</span><br><span class="line">   create : myapp/app.js</span><br><span class="line">   create : myapp/public</span><br><span class="line">   create : myapp/public/javascripts</span><br><span class="line">   create : myapp/public/images</span><br><span class="line">   create : myapp/routes</span><br><span class="line">   create : myapp/routes/index.js</span><br><span class="line">   create : myapp/routes/users.js</span><br><span class="line">   create : myapp/public/stylesheets</span><br><span class="line">   create : myapp/public/stylesheets/style.css</span><br><span class="line">   create : myapp/views</span><br><span class="line">   create : myapp/views/index.jade</span><br><span class="line">   create : myapp/views/layout.jade</span><br><span class="line">   create : myapp/views/error.jade</span><br><span class="line">   create : myapp/bin</span><br><span class="line">   create : myapp/bin/www</span><br></pre></td></tr></table></figure><p>然后安装所有依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myapp </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure><p>启动这个应用（MacOS 或 Linux 平台）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> DEBUG=myapp npm start</span></span><br></pre></td></tr></table></figure><p>Windows 平台使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> DEBUG=myapp &amp; npm start</span></span><br></pre></td></tr></table></figure><p>然后在浏览器中打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 网址就可以看到这个应用了。</p><p>通过 Express 应用生成器创建的应用一般都有如下目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.jade</span><br><span class="line">    ├── index.jade</span><br><span class="line">    └── layout.jade</span><br><span class="line"></span><br><span class="line">7 directories, 9 files</span><br></pre></td></tr></table></figure><blockquote><p>通过 Express 应用生成器创建应用只是众多方法中的一种。你可以不使用它，也可以修改它让它符合你的需求，都是开源的嘛！</p></blockquote><h1 id="一个简单的-Express-路由"><a href="#一个简单的-Express-路由" class="headerlink" title="一个简单的 Express 路由"></a>一个简单的 Express 路由</h1><p>这篇教程只是对 Express 路由做一个简单的介绍。路由（Routing）是由一个 URI（或者叫路径）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何响应客户端对某个网站节点的访问。</p><p>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个/些函数将被执行。</p><p>路由的定义由如下结构组成：<code>app.METHOD(PATH, HANDLER)</code>。其中，<code>app</code> 是一个 <code>express</code> 实例；METHOD 是某个 HTTP 请求方式中的一个；PATH 是服务器端的路径；HANDLER 是当路由匹配到时需要执行的函数。</p><p>本教程假定已经存在一个命名为 <code>app</code> 的 <code>express</code> 实例了，并且应用程序是运行状态。如果你还不熟悉如何创建一个应用并使其运行，请参考 Hello world 实例。</p><p>下面的代码展示了几个路由实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对网站首页的访问返回 "Hello World!" 字样</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站首页接受 POST 请求</span></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a POST request'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /user 节点接受 PUT 请求</span></span><br><span class="line">app.put(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a PUT request at /user'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /user 节点接受 DELETE 请求</span></span><br><span class="line">app.delete(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Got a DELETE request at /user'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于路由的详细资料，请参考 路由指南 章节。</p><h1 id="利用-Express-托管静态文件"><a href="#利用-Express-托管静态文件" class="headerlink" title="利用 Express 托管静态文件"></a>利用 Express 托管静态文件</h1><p>通过 Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。</p><p>将静态资源文件所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了。例如，假设在 public 目录放置了图片、CSS 和 JavaScript 文件，你就可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure><p>现在，public 目录下面的文件就可以访问了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:3000/images/kitten.jpg</span><br><span class="line">http://localhost:3000/css/style.css</span><br><span class="line">http://localhost:3000/js/app.js</span><br><span class="line">http://localhost:3000/images/bg.png</span><br><span class="line">http://localhost:3000/hello.html</span><br></pre></td></tr></table></figure><blockquote><p>所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。</p></blockquote><p>如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line">app.use(express.static(<span class="string">'files'</span>));</span><br></pre></td></tr></table></figure><p>访问静态资源文件时，express.static 中间件会根据目录添加的顺序查找所需的文件。</p><p>如果你希望所有通过 express.static 访问的文件都存放在一个“虚拟（virtual）”目录（即目录根本不存在）下面，可以通过为静态资源目录指定一个挂载路径的方式来实现，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">'/static'</span>, express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure><p>现在，你就爱可以通过带有 “/static” 前缀的地址来访问 public 目录下面的文件了。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http://localhost:3000/static/images/kitten.jpg</span></span><br><span class="line"><span class="attribute">http://localhost:3000/static/css/style.css</span></span><br><span class="line"><span class="attribute">http://localhost:3000/static/js/app.js</span></span><br><span class="line"><span class="attribute">http://localhost:3000/static/images/bg.png</span></span><br><span class="line"><span class="attribute">http://localhost:3000/static/hello.html</span></span><br></pre></td></tr></table></figure><h1 id="Express-常见问题"><a href="#Express-常见问题" class="headerlink" title="Express 常见问题"></a>Express 常见问题</h1><h2 id="我的应用该如何组织？"><a href="#我的应用该如何组织？" class="headerlink" title="我的应用该如何组织？"></a>我的应用该如何组织？</h2><p>对于这个问题其实没有一个确定的答案。这要根据你的应用的规模和参与开发的团队来确定。为了尽可能灵活，Express 自身是并没有硬性要求应用结构是哪一种的。</p><p>根据你的需求，可以把路由和其他应用相关的业务逻辑存放在任意多个文件和任意目录中。下面推荐的实例或许对你能有一些启发：</p><ul><li>Route listings</li><li>Route map</li><li>MVC style controllers</li></ul><p>另外，这里还有一些第三方 Express 扩展简化了这种组织方式：</p><ul><li>Resourceful routing</li></ul><h2 id="如何定义模型（model）？"><a href="#如何定义模型（model）？" class="headerlink" title="如何定义模型（model）？"></a>如何定义模型（model）？</h2><p>Express自身并不感知数据库是否存在。数据库功能依赖于第三方 Node 模块提供的接口。</p><h2 id="如何验证用户？"><a href="#如何验证用户？" class="headerlink" title="如何验证用户？"></a>如何验证用户？</h2><p>这是另一个 Express 不涉及的领域。你可以使用任何验证方式。对于简单的用户名/密码验证方式，可以参考<a href="https://github.com/expressjs/express/tree/master/examples/auth" target="_blank" rel="noopener">这个实例</a>。</p><h2 id="Express-支持哪些模板引擎？"><a href="#Express-支持哪些模板引擎？" class="headerlink" title="Express 支持哪些模板引擎？"></a>Express 支持哪些模板引擎？</h2><p>Express 支持任何符合 (path, locals, callback) 接口规范的模板引擎。 为了统一模板引擎的接口和缓存功能，请参考 consolidate.js 项目。其他未提及的模板引擎也可能支持 Express 接口规范。</p><h2 id="如何处理-404-？"><a href="#如何处理-404-？" class="headerlink" title="如何处理 404 ？"></a>如何处理 404 ？</h2><p>在 Express 中，404 并不是一个错误（error）。因此，错误处理器中间件并不捕获 404。这是因为 404 只是意味着某些功能没有实现。也就是说，Express 执行了所有中间件、路由之后还是没有获取到任何输出。你所需要做的就是在其所有他中间件的后面添加一个处理 404 的中间件。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.status(<span class="number">404</span>).send(<span class="string">'Sorry cant find that!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="如何设置一个错误处理器？"><a href="#如何设置一个错误处理器？" class="headerlink" title="如何设置一个错误处理器？"></a>如何设置一个错误处理器？</h1><p>错误处理器中间件的定义和其他中间件一样，唯一的区别是 4 个而不是 3 个参数，即 (err, req, res, next)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">'Something broke!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>请参考错误处理章节以了解更多信息。</p><h1 id="如何渲染纯-HTML-文件？"><a href="#如何渲染纯-HTML-文件？" class="headerlink" title="如何渲染纯 HTML 文件？"></a>如何渲染纯 HTML 文件？</h1><p>不需要！无需通过 <code>res.render()</code> 渲染 <code>HTML</code>。你可以通过 <code>res.sendFile()</code> 直接对外输出 <code>HTML</code> 文件。如果你需要对外提供的资源文件很多，可以使用 <code>express.static()</code> 中间件。</p>]]></content>
      
      
      <categories>
          
          <category> Express 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Express </tag>
            
            <tag>  NodeJS </tag>
            
            <tag> Express 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
